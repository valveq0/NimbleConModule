{"version":3,"file":"waveform-data.min.js","sources":["../src/waveform-data-channel.js","../src/waveform-generator.js","../src/waveform-data.js","../src/waveform-utils.js"],"sourcesContent":["/**\n * Provides access to the waveform data for a single audio channel.\n */\n\nfunction WaveformDataChannel(waveformData, channelIndex) {\n  this._waveformData = waveformData;\n  this._channelIndex = channelIndex;\n}\n\n/**\n * Returns the waveform minimum at the given index position.\n */\n\nWaveformDataChannel.prototype.min_sample = function(index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n\n  return this._waveformData._at(offset);\n};\n\n/**\n * Returns the waveform maximum at the given index position.\n */\n\nWaveformDataChannel.prototype.max_sample = function(index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n\n  return this._waveformData._at(offset);\n};\n\n/**\n * Sets the waveform minimum at the given index position.\n */\n\nWaveformDataChannel.prototype.set_min_sample = function(index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n\n  return this._waveformData._set_at(offset, sample);\n};\n\n/**\n * Sets the waveform maximum at the given index position.\n */\n\nWaveformDataChannel.prototype.set_max_sample = function(index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n\n  return this._waveformData._set_at(offset, sample);\n};\n\n/**\n * Returns all the waveform minimum values as an array.\n */\n\nWaveformDataChannel.prototype.min_array = function() {\n  var length = this._waveformData.length;\n  var values = [];\n\n  for (var i = 0; i < length; i++) {\n    values.push(this.min_sample(i));\n  }\n\n  return values;\n};\n\n/**\n * Returns all the waveform maximum values as an array.\n */\n\nWaveformDataChannel.prototype.max_array = function() {\n  var length = this._waveformData.length;\n  var values = [];\n\n  for (var i = 0; i < length; i++) {\n    values.push(this.max_sample(i));\n  }\n\n  return values;\n};\n\nexport default WaveformDataChannel;\n","/**\n * AudioBuffer-based WaveformData generator\n *\n * Adapted from BlockFile::CalcSummary in Audacity, with permission.\n * See https://github.com/audacity/audacity/blob/\n *   1108c1376c09166162335fab4743008cba57c4ee/src/BlockFile.cpp#L198\n */\n\nvar INT8_MAX = 127;\nvar INT8_MIN = -128;\n\nvar INT16_MAX = 32767;\nvar INT16_MIN = -32768;\n\nfunction calculateWaveformDataLength(audio_sample_count, scale) {\n  var data_length = Math.floor(audio_sample_count / scale);\n\n  var samples_remaining = audio_sample_count - (data_length * scale);\n\n  if (samples_remaining > 0) {\n    data_length++;\n  }\n\n  return data_length;\n}\n\nfunction generateWaveformData(options) {\n  var scale = options.scale;\n  var amplitude_scale = options.amplitude_scale;\n  var split_channels = options.split_channels;\n  var length = options.length;\n  var sample_rate = options.sample_rate;\n  var channels = options.channels.map(function(channel) {\n    return new Float32Array(channel);\n  });\n  var output_channels = split_channels ? channels.length : 1;\n  var header_size = 24;\n  var data_length = calculateWaveformDataLength(length, scale);\n  var bytes_per_sample = options.bits === 8 ? 1 : 2;\n  var total_size = header_size + data_length * 2 * bytes_per_sample * output_channels;\n  var buffer = new ArrayBuffer(total_size);\n  var data_view = new DataView(buffer);\n\n  var scale_counter = 0;\n  var offset = header_size;\n  var channel, i;\n\n  var min_value = new Array(output_channels);\n  var max_value = new Array(output_channels);\n\n  for (channel = 0; channel < output_channels; channel++) {\n    min_value[channel] = Infinity;\n    max_value[channel] = -Infinity;\n  }\n\n  var range_min = options.bits === 8 ? INT8_MIN : INT16_MIN;\n  var range_max = options.bits === 8 ? INT8_MAX : INT16_MAX;\n\n  data_view.setInt32(0, 2, true); // Version\n  data_view.setUint32(4, options.bits === 8, true); // Is 8 bit?\n  data_view.setInt32(8, sample_rate, true); // Sample rate\n  data_view.setInt32(12, scale, true); // Scale\n  data_view.setInt32(16, data_length, true); // Length\n  data_view.setInt32(20, output_channels, true);\n\n  for (i = 0; i < length; i++) {\n    var sample = 0;\n\n    if (output_channels === 1) {\n      for (channel = 0; channel < channels.length; ++channel) {\n        sample += channels[channel][i];\n      }\n\n      sample = Math.floor(range_max * sample * amplitude_scale / channels.length);\n\n      if (sample < min_value[0]) {\n        min_value[0] = sample;\n\n        if (min_value[0] < range_min) {\n          min_value[0] = range_min;\n        }\n      }\n\n      if (sample > max_value[0]) {\n        max_value[0] = sample;\n\n        if (max_value[0] > range_max) {\n          max_value[0] = range_max;\n        }\n      }\n    }\n    else {\n      for (channel = 0; channel < output_channels; ++channel) {\n        sample = Math.floor(range_max * channels[channel][i] * amplitude_scale);\n\n        if (sample < min_value[channel]) {\n          min_value[channel] = sample;\n\n          if (min_value[channel] < range_min) {\n            min_value[channel] = range_min;\n          }\n        }\n\n        if (sample > max_value[channel]) {\n          max_value[channel] = sample;\n\n          if (max_value[channel] > range_max) {\n            max_value[channel] = range_max;\n          }\n        }\n      }\n    }\n\n    if (++scale_counter === scale) {\n      for (channel = 0; channel < output_channels; channel++) {\n        if (options.bits === 8) {\n          data_view.setInt8(offset++, min_value[channel]);\n          data_view.setInt8(offset++, max_value[channel]);\n        }\n        else {\n          data_view.setInt16(offset, min_value[channel], true);\n          data_view.setInt16(offset + 2, max_value[channel], true);\n          offset += 4;\n        }\n\n        min_value[channel] = Infinity;\n        max_value[channel] = -Infinity;\n      }\n\n      scale_counter = 0;\n    }\n  }\n\n  if (scale_counter > 0) {\n    for (channel = 0; channel < output_channels; channel++) {\n      if (options.bits === 8) {\n        data_view.setInt8(offset++, min_value[channel]);\n        data_view.setInt8(offset++, max_value[channel]);\n      }\n      else {\n        data_view.setInt16(offset, min_value[channel], true);\n        data_view.setInt16(offset + 2, max_value[channel], true);\n      }\n    }\n  }\n\n  return buffer;\n}\n\nexport { generateWaveformData };\n","import WaveformDataChannel from \"./waveform-data-channel\";\nimport { generateWaveformData } from \"./waveform-generator\";\nimport { isJsonWaveformData, isBinaryWaveformData, convertJsonToBinary } from \"./waveform-utils\";\nimport WaveformDataWorker from \"web-worker:./waveform-data-worker\";\n\n/**\n * Provides access to waveform data.\n */\n\nfunction WaveformData(data) {\n  if (isJsonWaveformData(data)) {\n    data = convertJsonToBinary(data);\n  }\n\n  if (isBinaryWaveformData(data)) {\n    this._data = new DataView(data);\n    this._offset = this._version() === 2 ? 24 : 20;\n\n    this._channels = [];\n\n    for (var channel = 0; channel < this.channels; channel++) {\n      this._channels[channel] = new WaveformDataChannel(this, channel);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"WaveformData.create(): Unknown data format\"\n    );\n  }\n}\n\nvar defaultOptions = {\n  scale: 512,\n  bits: 8,\n  amplitude_scale: 1.0,\n  split_channels: false,\n  disable_worker: false\n};\n\nfunction getOptions(options) {\n  var opts = {\n    scale: options.scale || defaultOptions.scale,\n    bits: options.bits || defaultOptions.bits,\n    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,\n    split_channels: options.split_channels || defaultOptions.split_channels,\n    disable_worker: options.disable_worker || defaultOptions.disable_worker\n  };\n\n  return opts;\n}\n\nfunction getChannelData(audio_buffer) {\n  var channels = [];\n\n  for (var i = 0; i < audio_buffer.numberOfChannels; ++i) {\n    channels.push(audio_buffer.getChannelData(i).buffer);\n  }\n\n  return channels;\n}\n\nfunction createFromAudioBuffer(audio_buffer, options, callback) {\n  var channels = getChannelData(audio_buffer);\n\n  if (options.disable_worker) {\n    var buffer = generateWaveformData({\n      scale: options.scale,\n      bits: options.bits,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    });\n\n    callback(null, new WaveformData(buffer), audio_buffer);\n  }\n  else {\n    var worker = new WaveformDataWorker();\n\n    worker.onmessage = function(evt) {\n      callback(null, new WaveformData(evt.data), audio_buffer);\n    };\n\n    worker.postMessage({\n      scale: options.scale,\n      bits: options.bits,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    }, channels);\n  }\n}\n\nfunction createFromArrayBuffer(audioContext, audioData, options, callback) {\n  // The following function is a workaround for a Webkit bug where decodeAudioData\n  // invokes the errorCallback with null instead of a DOMException.\n  // See https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata\n  // and http://stackoverflow.com/q/10365335/103396\n\n  function errorCallback(error) {\n    if (!error) {\n      error = new DOMException(\"EncodingError\");\n    }\n\n    callback(error);\n    // prevent double-calling the callback on errors:\n    callback = function() { };\n  }\n\n  var promise = audioContext.decodeAudioData(\n    audioData,\n    function(audio_buffer) {\n      createFromAudioBuffer(audio_buffer, options, callback);\n    },\n    errorCallback\n  );\n\n  if (promise) {\n    promise.catch(errorCallback);\n  }\n}\n\n/**\n * Creates and returns a WaveformData instance from the given waveform data.\n */\n\nWaveformData.create = function create(data) {\n  return new WaveformData(data);\n};\n\n/**\n * Creates a WaveformData instance from audio.\n */\n\nWaveformData.createFromAudio = function(options, callback) {\n  var opts = getOptions(options);\n\n  if (options.audio_context && options.array_buffer) {\n    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);\n  }\n  else if (options.audio_buffer) {\n    return createFromAudioBuffer(options.audio_buffer, opts, callback);\n  }\n  else {\n    throw new TypeError(\n      // eslint-disable-next-line\n      \"WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object\"\n    );\n  }\n};\n\nfunction WaveformResampler(options) {\n  this._inputData = options.waveformData;\n\n  // Scale we want to reach\n  this._output_samples_per_pixel = options.scale;\n\n  this._scale = this._inputData.scale; // scale we are coming from\n\n  // The amount of data we want to resample i.e. final zoom want to resample\n  // all data but for intermediate zoom we want to resample subset\n  this._input_buffer_size = this._inputData.length;\n\n  var input_buffer_length_samples = this._input_buffer_size * this._inputData.scale;\n  var output_buffer_length_samples =\n    Math.ceil(input_buffer_length_samples / this._output_samples_per_pixel);\n\n  var output_header_size = 24; // version 2\n  var bytes_per_sample = this._inputData.bits === 8 ? 1 : 2;\n  var total_size = output_header_size\n                  + output_buffer_length_samples * 2 * this._inputData.channels * bytes_per_sample;\n\n  this._output_data = new ArrayBuffer(total_size);\n\n  this.output_dataview = new DataView(this._output_data);\n\n  this.output_dataview.setInt32(0, 2, true); // Version\n  this.output_dataview.setUint32(4, this._inputData.bits === 8, true); // Is 8 bit?\n  this.output_dataview.setInt32(8, this._inputData.sample_rate, true);\n  this.output_dataview.setInt32(12, this._output_samples_per_pixel, true);\n  this.output_dataview.setInt32(16, output_buffer_length_samples, true);\n  this.output_dataview.setInt32(20, this._inputData.channels, true);\n\n  this._outputWaveformData = new WaveformData(this._output_data);\n\n  this._input_index = 0;\n  this._output_index = 0;\n\n  var channels = this._inputData.channels;\n\n  this._min = new Array(channels);\n  this._max = new Array(channels);\n\n  var channel;\n\n  for (channel = 0; channel < channels; ++channel) {\n    if (this._input_buffer_size > 0) {\n      this._min[channel] = this._inputData.channel(channel).min_sample(this._input_index);\n      this._max[channel] = this._inputData.channel(channel).max_sample(this._input_index);\n    }\n    else {\n      this._min[channel] = 0;\n      this._max[channel] = 0;\n    }\n  }\n\n  this._min_value = this._inputData.bits === 8 ? -128 : -32768;\n  this._max_value = this._inputData.bits === 8 ?  127 :  32767;\n\n  this._where = 0;\n  this._prev_where = 0;\n  this._stop = 0;\n  this._last_input_index = 0;\n}\n\nWaveformResampler.prototype.sample_at_pixel = function(x) {\n  return Math.floor(x * this._output_samples_per_pixel);\n};\n\nWaveformResampler.prototype.next = function() {\n  var count = 0;\n  var total = 1000;\n  var channels = this._inputData.channels;\n  var channel;\n  var value;\n  var i;\n\n  while (this._input_index < this._input_buffer_size && count < total) {\n    while (Math.floor(this.sample_at_pixel(this._output_index) / this._scale) ===\n           this._input_index) {\n      if (this._output_index > 0) {\n        for (i = 0; i < channels; ++i) {\n          channel = this._outputWaveformData.channel(i);\n\n          channel.set_min_sample(this._output_index - 1, this._min[i]);\n          channel.set_max_sample(this._output_index - 1, this._max[i]);\n        }\n      }\n\n      this._last_input_index = this._input_index;\n\n      this._output_index++;\n\n      this._where      = this.sample_at_pixel(this._output_index);\n      this._prev_where = this.sample_at_pixel(this._output_index - 1);\n\n      if (this._where !== this._prev_where) {\n        for (i = 0; i < channels; ++i) {\n          this._min[i] = this._max_value;\n          this._max[i] = this._min_value;\n        }\n      }\n    }\n\n    this._where = this.sample_at_pixel(this._output_index);\n    this._stop = Math.floor(this._where / this._scale);\n\n    if (this._stop > this._input_buffer_size) {\n      this._stop = this._input_buffer_size;\n    }\n\n    while (this._input_index < this._stop) {\n      for (i = 0; i < channels; ++i) {\n        channel = this._inputData.channel(i);\n\n        value = channel.min_sample(this._input_index);\n\n        if (value < this._min[i]) {\n          this._min[i] = value;\n        }\n\n        value = channel.max_sample(this._input_index);\n\n        if (value > this._max[i]) {\n          this._max[i] = value;\n        }\n      }\n\n      this._input_index++;\n    }\n\n    count++;\n  }\n\n  if (this._input_index < this._input_buffer_size) {\n    // More to do\n    return false;\n  }\n  else {\n    // Done\n    if (this._input_index !== this._last_input_index) {\n      for (i = 0; i < channels; ++i) {\n        channel = this._outputWaveformData.channel(i);\n\n        channel.set_min_sample(this._output_index - 1, this._min[i]);\n        channel.set_max_sample(this._output_index - 1, this._max[i]);\n      }\n    }\n\n    return true;\n  }\n};\n\nWaveformResampler.prototype.getOutputData = function() {\n  return this._output_data;\n};\n\nWaveformData.prototype = {\n\n  _getResampleOptions(options) {\n    var opts = {};\n\n    opts.scale = options.scale;\n    opts.width = options.width;\n\n    if (opts.width != null && (typeof opts.width !== \"number\" || opts.width <= 0)) {\n      throw new RangeError(\"WaveformData.resample(): width should be a positive integer value\");\n    }\n\n    if (opts.scale != null && (typeof opts.scale !== \"number\" || opts.scale <= 0)) {\n      throw new RangeError(\"WaveformData.resample(): scale should be a positive integer value\");\n    }\n\n    if (!opts.scale && !opts.width) {\n      throw new Error(\"WaveformData.resample(): Missing scale or width option\");\n    }\n\n    if (opts.width) {\n      // Calculate the target scale for the resampled waveform\n      opts.scale = Math.floor(this.duration * this.sample_rate / opts.width);\n    }\n\n    if (opts.scale < this.scale) {\n      throw new Error(\n        \"WaveformData.resample(): Zoom level \" + opts.scale +\n        \" too low, minimum: \" + this.scale\n      );\n    }\n\n    opts.abortSignal = options.abortSignal;\n\n    return opts;\n  },\n\n  resample: function(options) {\n    options = this._getResampleOptions(options);\n    options.waveformData = this;\n\n    var resampler = new WaveformResampler(options);\n\n    while (!resampler.next()) {\n      // nothing\n    }\n\n    return new WaveformData(resampler.getOutputData());\n  },\n\n  /**\n   * Concatenates with one or more other waveforms, returning a new WaveformData object.\n   */\n\n  concat: function() {\n    var self = this;\n    var otherWaveforms = Array.prototype.slice.call(arguments);\n\n    // Check that all the supplied waveforms are compatible\n    otherWaveforms.forEach(function(otherWaveform) {\n      if (self.channels !== otherWaveform.channels ||\n        self.sample_rate !== otherWaveform.sample_rate ||\n        self.bits !== otherWaveform.bits ||\n        self.scale !== otherWaveform.scale) {\n        throw new Error(\"WaveformData.concat(): Waveforms are incompatible\");\n      }\n    });\n\n    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);\n\n    return WaveformData.create(combinedBuffer);\n  },\n\n  /**\n   * Returns a new ArrayBuffer with the concatenated waveform.\n   * All waveforms must have identical metadata (version, channels, etc)\n   */\n\n  _concatBuffers: function() {\n    var otherWaveforms = Array.prototype.slice.call(arguments);\n    var headerSize = this._offset;\n    var totalSize = headerSize;\n    var totalDataLength = 0;\n    var bufferCollection = [this].concat(otherWaveforms).map(function(w) {\n      return w._data.buffer;\n    });\n    var i, buffer;\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      var dataSize = new DataView(buffer).getInt32(16, true);\n\n      totalSize += buffer.byteLength - headerSize;\n      totalDataLength += dataSize;\n    }\n\n    var totalBuffer = new ArrayBuffer(totalSize);\n    var sourceHeader = new DataView(bufferCollection[0]);\n    var totalBufferView = new DataView(totalBuffer);\n\n    // Copy the header from the first chunk\n    for (i = 0; i < headerSize; i++) {\n      totalBufferView.setUint8(i, sourceHeader.getUint8(i));\n    }\n    // Rewrite the data-length header item to reflect all of the samples concatenated together\n    totalBufferView.setInt32(16, totalDataLength, true);\n\n    var offset = 0;\n    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);\n      offset += buffer.byteLength - headerSize;\n    }\n\n    return totalBuffer;\n  },\n\n  slice: function(options) {\n    var startIndex = 0;\n    var endIndex = 0;\n\n    if (options.startIndex != null && options.endIndex != null) {\n      startIndex = options.startIndex;\n      endIndex = options.endIndex;\n    }\n    else if (options.startTime != null && options.endTime != null) {\n      startIndex = this.at_time(options.startTime);\n      endIndex = this.at_time(options.endTime);\n    }\n\n    if (startIndex < 0) {\n      throw new RangeError(\"startIndex or startTime must not be negative\");\n    }\n\n    if (endIndex < 0) {\n      throw new RangeError(\"endIndex or endTime must not be negative\");\n    }\n\n    if (startIndex > this.length) {\n      startIndex = this.length;\n    }\n\n    if (endIndex > this.length) {\n      endIndex = this.length;\n    }\n\n    if (startIndex > endIndex) {\n      startIndex = endIndex;\n    }\n\n    var length = endIndex - startIndex;\n\n    var header_size = 24; // Version 2\n    var bytes_per_sample = this.bits === 8 ? 1 : 2;\n    var total_size = header_size\n                   + length * 2 * this.channels * bytes_per_sample;\n\n    var output_data = new ArrayBuffer(total_size);\n    var output_dataview = new DataView(output_data);\n\n    output_dataview.setInt32(0, 2, true); // Version\n    output_dataview.setUint32(4, this.bits === 8, true); // Is 8 bit?\n    output_dataview.setInt32(8, this.sample_rate, true);\n    output_dataview.setInt32(12, this.scale, true);\n    output_dataview.setInt32(16, length, true);\n    output_dataview.setInt32(20, this.channels, true);\n\n    for (var i = 0; i < length * this.channels * 2; i++) {\n      var sample = this._at(startIndex * this.channels * 2 + i);\n\n      if (this.bits === 8) {\n        output_dataview.setInt8(header_size + i, sample);\n      }\n      else {\n        output_dataview.setInt16(header_size + i * 2, sample, true);\n      }\n    }\n\n    return new WaveformData(output_data);\n  },\n\n  /**\n   * Returns the data format version number.\n   */\n\n  _version: function() {\n    return this._data.getInt32(0, true);\n  },\n\n  /**\n   * Returns the length of the waveform, in pixels.\n   */\n\n  get length() {\n    return this._data.getUint32(16, true);\n  },\n\n  /**\n   * Returns the number of bits per sample, either 8 or 16.\n   */\n\n  get bits() {\n    var bits = Boolean(this._data.getUint32(4, true));\n\n    return bits ? 8 : 16;\n  },\n\n  /**\n   * Returns the (approximate) duration of the audio file, in seconds.\n   */\n\n  get duration() {\n    return this.length * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of pixels per second.\n   */\n\n  get pixels_per_second() {\n    return this.sample_rate / this.scale;\n  },\n\n  /**\n   * Returns the amount of time represented by a single pixel, in seconds.\n   */\n\n  get seconds_per_pixel() {\n    return this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of waveform channels.\n   */\n\n  get channels() {\n    if (this._version() === 2) {\n      return this._data.getInt32(20, true);\n    }\n    else {\n      return 1;\n    }\n  },\n\n  /**\n   * Returns a waveform channel.\n   */\n\n  channel: function(index) {\n    if (index >= 0 && index < this._channels.length) {\n      return this._channels[index];\n    }\n    else {\n      throw new RangeError(\"Invalid channel: \" + index);\n    }\n  },\n\n  /**\n   * Returns the number of audio samples per second.\n   */\n\n  get sample_rate() {\n    return this._data.getInt32(8, true);\n  },\n\n  /**\n   * Returns the number of audio samples per pixel.\n   */\n\n  get scale() {\n    return this._data.getInt32(12, true);\n  },\n\n  /**\n   * Returns a waveform data value at a specific offset.\n   */\n\n  _at: function at_sample(index) {\n    if (this.bits === 8) {\n      return this._data.getInt8(this._offset + index);\n    }\n    else {\n      return this._data.getInt16(this._offset + index * 2, true);\n    }\n  },\n\n  /**\n   * Sets a waveform data value at a specific offset.\n   */\n\n  _set_at: function set_at(index, sample) {\n    if (this.bits === 8) {\n      return this._data.setInt8(this._offset + index, sample);\n    }\n    else {\n      return this._data.setInt16(this._offset + index * 2, sample, true);\n    }\n  },\n\n  /**\n   * Returns the waveform data index position for a given time.\n   */\n\n  at_time: function at_time(time) {\n    return Math.floor(time * this.sample_rate / this.scale);\n  },\n\n  /**\n   * Returns the time in seconds for a given index.\n   */\n\n  time: function time(index) {\n    return index * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns an object containing the waveform data.\n   */\n\n  toJSON: function() {\n    const waveform = {\n      version: 2,\n      channels: this.channels,\n      sample_rate: this.sample_rate,\n      samples_per_pixel: this.scale,\n      bits: this.bits,\n      length: this.length,\n      data: []\n    };\n\n    for (var i = 0; i < this.length; i++) {\n      for (var channel = 0; channel < this.channels; channel++) {\n        waveform.data.push(this.channel(channel).min_sample(i));\n        waveform.data.push(this.channel(channel).max_sample(i));\n      }\n    }\n\n    return waveform;\n  },\n\n  /**\n   * Returns the waveform data in binary format as an ArrayBuffer.\n   */\n\n  toArrayBuffer: function() {\n    return this._data.buffer;\n  }\n};\n\nexport default WaveformData;\n","export function isJsonWaveformData(data) {\n  return data &&\n    typeof data === \"object\" &&\n    \"sample_rate\" in data &&\n    \"samples_per_pixel\" in data &&\n    \"bits\" in data &&\n    \"length\" in data &&\n    \"data\" in data;\n}\n\nexport function isBinaryWaveformData(data) {\n  var isCompatible = data && typeof data === \"object\" && \"byteLength\" in data;\n\n  if (isCompatible) {\n    var view = new DataView(data);\n    var version = view.getInt32(0, true);\n\n    if (version !== 1 && version !== 2) {\n      throw new TypeError(\"WaveformData.create(): This waveform data version not supported\");\n    }\n  }\n\n  return isCompatible;\n}\n\nexport function convertJsonToBinary(data) {\n  var waveformData = data.data;\n  var channels = data.channels || 1;\n  var header_size = 24; // version 2\n  var bytes_per_sample = data.bits === 8 ? 1 : 2;\n  var expected_length = data.length * 2 * channels;\n\n  if (waveformData.length !== expected_length) {\n    throw new Error(\"WaveformData.create(): Length mismatch in JSON waveform data\");\n  }\n\n  var total_size = header_size + waveformData.length * bytes_per_sample;\n\n  var array_buffer = new ArrayBuffer(total_size);\n  var data_object = new DataView(array_buffer);\n\n  data_object.setInt32(0, 2, true); // Version\n  data_object.setUint32(4, data.bits === 8, true);\n  data_object.setInt32(8, data.sample_rate, true);\n  data_object.setInt32(12, data.samples_per_pixel, true);\n  data_object.setInt32(16, data.length, true);\n  data_object.setInt32(20, channels, true);\n\n  var index = header_size;\n\n  var i;\n\n  if (data.bits === 8) {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt8(index++, waveformData[i], true);\n    }\n  }\n  else {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt16(index, waveformData[i], true);\n\n      index += 2;\n    }\n  }\n\n  return array_buffer;\n}\n"],"names":["WaveformDataChannel","waveformData","channelIndex","this","_waveformData","_channelIndex","prototype","min_sample","index","offset","channels","_at","max_sample","set_min_sample","sample","_set_at","set_max_sample","min_array","length","values","i","push","max_array","INT8_MAX","INT8_MIN","INT16_MAX","INT16_MIN","generateWaveformData","options","channel","scale","amplitude_scale","split_channels","sample_rate","map","Float32Array","output_channels","data_length","audio_sample_count","Math","floor","calculateWaveformDataLength","bytes_per_sample","bits","buffer","ArrayBuffer","data_view","DataView","scale_counter","min_value","Array","max_value","Infinity","range_min","range_max","setInt32","setUint32","setInt8","setInt16","WaveformData","data","_typeof","isJsonWaveformData","expected_length","Error","total_size","array_buffer","data_object","samples_per_pixel","convertJsonToBinary","isCompatible","version","getInt32","TypeError","isBinaryWaveformData","_data","_offset","_version","_channels","defaultOptions","createFromAudioBuffer","audio_buffer","callback","numberOfChannels","getChannelData","disable_worker","sampleRate","worker","WaveformDataWorker","onmessage","evt","postMessage","WaveformResampler","_inputData","_output_samples_per_pixel","_scale","_input_buffer_size","input_buffer_length_samples","output_buffer_length_samples","ceil","_output_data","output_dataview","_outputWaveformData","_input_index","_output_index","_min","_max","_min_value","_max_value","_where","_prev_where","_stop","_last_input_index","create","createFromAudio","opts","getOptions","audio_context","audioContext","audioData","errorCallback","error","DOMException","promise","decodeAudioData","catch","createFromArrayBuffer","sample_at_pixel","x","next","value","count","getOutputData","_getResampleOptions","width","RangeError","duration","abortSignal","resample","resampler","concat","self","otherWaveforms","slice","call","arguments","forEach","otherWaveform","combinedBuffer","_concatBuffers","apply","headerSize","totalSize","totalDataLength","bufferCollection","w","dataSize","byteLength","totalBuffer","sourceHeader","totalBufferView","setUint8","getUint8","dataOfTotalBuffer","Uint8Array","set","startIndex","endIndex","startTime","endTime","at_time","output_data","getUint32","Boolean","pixels_per_second","seconds_per_pixel","getInt8","getInt16","time","toJSON","waveform","toArrayBuffer"],"mappings":"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"}