'use strict';

/**
 * Provides access to the waveform data for a single audio channel.
 */

function WaveformDataChannel(waveformData, channelIndex) {
  this._waveformData = waveformData;
  this._channelIndex = channelIndex;
}

/**
 * Returns the waveform minimum at the given index position.
 */

WaveformDataChannel.prototype.min_sample = function (index) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;
  return this._waveformData._at(offset);
};

/**
 * Returns the waveform maximum at the given index position.
 */

WaveformDataChannel.prototype.max_sample = function (index) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;
  return this._waveformData._at(offset);
};

/**
 * Sets the waveform minimum at the given index position.
 */

WaveformDataChannel.prototype.set_min_sample = function (index, sample) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;
  return this._waveformData._set_at(offset, sample);
};

/**
 * Sets the waveform maximum at the given index position.
 */

WaveformDataChannel.prototype.set_max_sample = function (index, sample) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;
  return this._waveformData._set_at(offset, sample);
};

/**
 * Returns all the waveform minimum values as an array.
 */

WaveformDataChannel.prototype.min_array = function () {
  var length = this._waveformData.length;
  var values = [];
  for (var i = 0; i < length; i++) {
    values.push(this.min_sample(i));
  }
  return values;
};

/**
 * Returns all the waveform maximum values as an array.
 */

WaveformDataChannel.prototype.max_array = function () {
  var length = this._waveformData.length;
  var values = [];
  for (var i = 0; i < length; i++) {
    values.push(this.max_sample(i));
  }
  return values;
};

/**
 * AudioBuffer-based WaveformData generator
 *
 * Adapted from BlockFile::CalcSummary in Audacity, with permission.
 * See https://github.com/audacity/audacity/blob/
 *   1108c1376c09166162335fab4743008cba57c4ee/src/BlockFile.cpp#L198
 */

var INT8_MAX = 127;
var INT8_MIN = -128;
var INT16_MAX = 32767;
var INT16_MIN = -32768;
function calculateWaveformDataLength(audio_sample_count, scale) {
  var data_length = Math.floor(audio_sample_count / scale);
  var samples_remaining = audio_sample_count - data_length * scale;
  if (samples_remaining > 0) {
    data_length++;
  }
  return data_length;
}
function generateWaveformData(options) {
  var scale = options.scale;
  var amplitude_scale = options.amplitude_scale;
  var split_channels = options.split_channels;
  var length = options.length;
  var sample_rate = options.sample_rate;
  var channels = options.channels.map(function (channel) {
    return new Float32Array(channel);
  });
  var output_channels = split_channels ? channels.length : 1;
  var header_size = 24;
  var data_length = calculateWaveformDataLength(length, scale);
  var bytes_per_sample = options.bits === 8 ? 1 : 2;
  var total_size = header_size + data_length * 2 * bytes_per_sample * output_channels;
  var buffer = new ArrayBuffer(total_size);
  var data_view = new DataView(buffer);
  var scale_counter = 0;
  var offset = header_size;
  var channel, i;
  var min_value = new Array(output_channels);
  var max_value = new Array(output_channels);
  for (channel = 0; channel < output_channels; channel++) {
    min_value[channel] = Infinity;
    max_value[channel] = -Infinity;
  }
  var range_min = options.bits === 8 ? INT8_MIN : INT16_MIN;
  var range_max = options.bits === 8 ? INT8_MAX : INT16_MAX;
  data_view.setInt32(0, 2, true); // Version
  data_view.setUint32(4, options.bits === 8, true); // Is 8 bit?
  data_view.setInt32(8, sample_rate, true); // Sample rate
  data_view.setInt32(12, scale, true); // Scale
  data_view.setInt32(16, data_length, true); // Length
  data_view.setInt32(20, output_channels, true);
  for (i = 0; i < length; i++) {
    var sample = 0;
    if (output_channels === 1) {
      for (channel = 0; channel < channels.length; ++channel) {
        sample += channels[channel][i];
      }
      sample = Math.floor(range_max * sample * amplitude_scale / channels.length);
      if (sample < min_value[0]) {
        min_value[0] = sample;
        if (min_value[0] < range_min) {
          min_value[0] = range_min;
        }
      }
      if (sample > max_value[0]) {
        max_value[0] = sample;
        if (max_value[0] > range_max) {
          max_value[0] = range_max;
        }
      }
    } else {
      for (channel = 0; channel < output_channels; ++channel) {
        sample = Math.floor(range_max * channels[channel][i] * amplitude_scale);
        if (sample < min_value[channel]) {
          min_value[channel] = sample;
          if (min_value[channel] < range_min) {
            min_value[channel] = range_min;
          }
        }
        if (sample > max_value[channel]) {
          max_value[channel] = sample;
          if (max_value[channel] > range_max) {
            max_value[channel] = range_max;
          }
        }
      }
    }
    if (++scale_counter === scale) {
      for (channel = 0; channel < output_channels; channel++) {
        if (options.bits === 8) {
          data_view.setInt8(offset++, min_value[channel]);
          data_view.setInt8(offset++, max_value[channel]);
        } else {
          data_view.setInt16(offset, min_value[channel], true);
          data_view.setInt16(offset + 2, max_value[channel], true);
          offset += 4;
        }
        min_value[channel] = Infinity;
        max_value[channel] = -Infinity;
      }
      scale_counter = 0;
    }
  }
  if (scale_counter > 0) {
    for (channel = 0; channel < output_channels; channel++) {
      if (options.bits === 8) {
        data_view.setInt8(offset++, min_value[channel]);
        data_view.setInt8(offset++, max_value[channel]);
      } else {
        data_view.setInt16(offset, min_value[channel], true);
        data_view.setInt16(offset + 2, max_value[channel], true);
      }
    }
  }
  return buffer;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function isJsonWaveformData(data) {
  return data && _typeof(data) === "object" && "sample_rate" in data && "samples_per_pixel" in data && "bits" in data && "length" in data && "data" in data;
}
function isBinaryWaveformData(data) {
  var isCompatible = data && _typeof(data) === "object" && "byteLength" in data;
  if (isCompatible) {
    var view = new DataView(data);
    var version = view.getInt32(0, true);
    if (version !== 1 && version !== 2) {
      throw new TypeError("WaveformData.create(): This waveform data version not supported");
    }
  }
  return isCompatible;
}
function convertJsonToBinary(data) {
  var waveformData = data.data;
  var channels = data.channels || 1;
  var header_size = 24; // version 2
  var bytes_per_sample = data.bits === 8 ? 1 : 2;
  var expected_length = data.length * 2 * channels;
  if (waveformData.length !== expected_length) {
    throw new Error("WaveformData.create(): Length mismatch in JSON waveform data");
  }
  var total_size = header_size + waveformData.length * bytes_per_sample;
  var array_buffer = new ArrayBuffer(total_size);
  var data_object = new DataView(array_buffer);
  data_object.setInt32(0, 2, true); // Version
  data_object.setUint32(4, data.bits === 8, true);
  data_object.setInt32(8, data.sample_rate, true);
  data_object.setInt32(12, data.samples_per_pixel, true);
  data_object.setInt32(16, data.length, true);
  data_object.setInt32(20, channels, true);
  var index = header_size;
  var i;
  if (data.bits === 8) {
    for (i = 0; i < waveformData.length; i++) {
      data_object.setInt8(index++, waveformData[i], true);
    }
  } else {
    for (i = 0; i < waveformData.length; i++) {
      data_object.setInt16(index, waveformData[i], true);
      index += 2;
    }
  }
  return array_buffer;
}

var WorkerClass = null;

try {
    var WorkerThreads =
        typeof module !== 'undefined' && typeof module.require === 'function' && module.require('worker_threads') ||
        typeof __non_webpack_require__ === 'function' && __non_webpack_require__('worker_threads') ||
        typeof require === 'function' && require('worker_threads');
    WorkerClass = WorkerThreads.Worker;
} catch(e) {} // eslint-disable-line

function decodeBase64$1(base64, enableUnicode) {
    return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');
}

function createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64$1(base64, enableUnicode);
    var start = source.indexOf('\n', 10) + 1;
    var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
    return function WorkerFactory(options) {
        return new WorkerClass(body, Object.assign({}, options, { eval: true }));
    };
}

function decodeBase64(base64, enableUnicode) {
    var binaryString = atob(base64);
    if (enableUnicode) {
        var binaryView = new Uint8Array(binaryString.length);
        for (var i = 0, n = binaryString.length; i < n; ++i) {
            binaryView[i] = binaryString.charCodeAt(i);
        }
        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
    }
    return binaryString;
}

function createURL(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64(base64, enableUnicode);
    var start = source.indexOf('\n', 10) + 1;
    var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
    var blob = new Blob([body], { type: 'application/javascript' });
    return URL.createObjectURL(blob);
}

function createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {
    var url;
    return function WorkerFactory(options) {
        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
        return new Worker(url, options);
    };
}

var kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

function isNodeJS() {
    return kIsNodeJS;
}

function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
    if (isNodeJS()) {
        return createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg);
    }
    return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);
}

var WorkerFactory = /*#__PURE__*/createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogQXVkaW9CdWZmZXItYmFzZWQgV2F2ZWZvcm1EYXRhIGdlbmVyYXRvcgogICAqCiAgICogQWRhcHRlZCBmcm9tIEJsb2NrRmlsZTo6Q2FsY1N1bW1hcnkgaW4gQXVkYWNpdHksIHdpdGggcGVybWlzc2lvbi4KICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F1ZGFjaXR5L2F1ZGFjaXR5L2Jsb2IvCiAgICogICAxMTA4YzEzNzZjMDkxNjYxNjIzMzVmYWI0NzQzMDA4Y2JhNTdjNGVlL3NyYy9CbG9ja0ZpbGUuY3BwI0wxOTgKICAgKi8KCiAgdmFyIElOVDhfTUFYID0gMTI3OwogIHZhciBJTlQ4X01JTiA9IC0xMjg7CiAgdmFyIElOVDE2X01BWCA9IDMyNzY3OwogIHZhciBJTlQxNl9NSU4gPSAtMzI3Njg7CiAgZnVuY3Rpb24gY2FsY3VsYXRlV2F2ZWZvcm1EYXRhTGVuZ3RoKGF1ZGlvX3NhbXBsZV9jb3VudCwgc2NhbGUpIHsKICAgIHZhciBkYXRhX2xlbmd0aCA9IE1hdGguZmxvb3IoYXVkaW9fc2FtcGxlX2NvdW50IC8gc2NhbGUpOwogICAgdmFyIHNhbXBsZXNfcmVtYWluaW5nID0gYXVkaW9fc2FtcGxlX2NvdW50IC0gZGF0YV9sZW5ndGggKiBzY2FsZTsKICAgIGlmIChzYW1wbGVzX3JlbWFpbmluZyA+IDApIHsKICAgICAgZGF0YV9sZW5ndGgrKzsKICAgIH0KICAgIHJldHVybiBkYXRhX2xlbmd0aDsKICB9CiAgZnVuY3Rpb24gZ2VuZXJhdGVXYXZlZm9ybURhdGEob3B0aW9ucykgewogICAgdmFyIHNjYWxlID0gb3B0aW9ucy5zY2FsZTsKICAgIHZhciBhbXBsaXR1ZGVfc2NhbGUgPSBvcHRpb25zLmFtcGxpdHVkZV9zY2FsZTsKICAgIHZhciBzcGxpdF9jaGFubmVscyA9IG9wdGlvbnMuc3BsaXRfY2hhbm5lbHM7CiAgICB2YXIgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGg7CiAgICB2YXIgc2FtcGxlX3JhdGUgPSBvcHRpb25zLnNhbXBsZV9yYXRlOwogICAgdmFyIGNoYW5uZWxzID0gb3B0aW9ucy5jaGFubmVscy5tYXAoZnVuY3Rpb24gKGNoYW5uZWwpIHsKICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoY2hhbm5lbCk7CiAgICB9KTsKICAgIHZhciBvdXRwdXRfY2hhbm5lbHMgPSBzcGxpdF9jaGFubmVscyA/IGNoYW5uZWxzLmxlbmd0aCA6IDE7CiAgICB2YXIgaGVhZGVyX3NpemUgPSAyNDsKICAgIHZhciBkYXRhX2xlbmd0aCA9IGNhbGN1bGF0ZVdhdmVmb3JtRGF0YUxlbmd0aChsZW5ndGgsIHNjYWxlKTsKICAgIHZhciBieXRlc19wZXJfc2FtcGxlID0gb3B0aW9ucy5iaXRzID09PSA4ID8gMSA6IDI7CiAgICB2YXIgdG90YWxfc2l6ZSA9IGhlYWRlcl9zaXplICsgZGF0YV9sZW5ndGggKiAyICogYnl0ZXNfcGVyX3NhbXBsZSAqIG91dHB1dF9jaGFubmVsczsKICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodG90YWxfc2l6ZSk7CiAgICB2YXIgZGF0YV92aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7CiAgICB2YXIgc2NhbGVfY291bnRlciA9IDA7CiAgICB2YXIgb2Zmc2V0ID0gaGVhZGVyX3NpemU7CiAgICB2YXIgY2hhbm5lbCwgaTsKICAgIHZhciBtaW5fdmFsdWUgPSBuZXcgQXJyYXkob3V0cHV0X2NoYW5uZWxzKTsKICAgIHZhciBtYXhfdmFsdWUgPSBuZXcgQXJyYXkob3V0cHV0X2NoYW5uZWxzKTsKICAgIGZvciAoY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBvdXRwdXRfY2hhbm5lbHM7IGNoYW5uZWwrKykgewogICAgICBtaW5fdmFsdWVbY2hhbm5lbF0gPSBJbmZpbml0eTsKICAgICAgbWF4X3ZhbHVlW2NoYW5uZWxdID0gLUluZmluaXR5OwogICAgfQogICAgdmFyIHJhbmdlX21pbiA9IG9wdGlvbnMuYml0cyA9PT0gOCA/IElOVDhfTUlOIDogSU5UMTZfTUlOOwogICAgdmFyIHJhbmdlX21heCA9IG9wdGlvbnMuYml0cyA9PT0gOCA/IElOVDhfTUFYIDogSU5UMTZfTUFYOwogICAgZGF0YV92aWV3LnNldEludDMyKDAsIDIsIHRydWUpOyAvLyBWZXJzaW9uCiAgICBkYXRhX3ZpZXcuc2V0VWludDMyKDQsIG9wdGlvbnMuYml0cyA9PT0gOCwgdHJ1ZSk7IC8vIElzIDggYml0PwogICAgZGF0YV92aWV3LnNldEludDMyKDgsIHNhbXBsZV9yYXRlLCB0cnVlKTsgLy8gU2FtcGxlIHJhdGUKICAgIGRhdGFfdmlldy5zZXRJbnQzMigxMiwgc2NhbGUsIHRydWUpOyAvLyBTY2FsZQogICAgZGF0YV92aWV3LnNldEludDMyKDE2LCBkYXRhX2xlbmd0aCwgdHJ1ZSk7IC8vIExlbmd0aAogICAgZGF0YV92aWV3LnNldEludDMyKDIwLCBvdXRwdXRfY2hhbm5lbHMsIHRydWUpOwogICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgIHZhciBzYW1wbGUgPSAwOwogICAgICBpZiAob3V0cHV0X2NoYW5uZWxzID09PSAxKSB7CiAgICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IGNoYW5uZWxzLmxlbmd0aDsgKytjaGFubmVsKSB7CiAgICAgICAgICBzYW1wbGUgKz0gY2hhbm5lbHNbY2hhbm5lbF1baV07CiAgICAgICAgfQogICAgICAgIHNhbXBsZSA9IE1hdGguZmxvb3IocmFuZ2VfbWF4ICogc2FtcGxlICogYW1wbGl0dWRlX3NjYWxlIC8gY2hhbm5lbHMubGVuZ3RoKTsKICAgICAgICBpZiAoc2FtcGxlIDwgbWluX3ZhbHVlWzBdKSB7CiAgICAgICAgICBtaW5fdmFsdWVbMF0gPSBzYW1wbGU7CiAgICAgICAgICBpZiAobWluX3ZhbHVlWzBdIDwgcmFuZ2VfbWluKSB7CiAgICAgICAgICAgIG1pbl92YWx1ZVswXSA9IHJhbmdlX21pbjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHNhbXBsZSA+IG1heF92YWx1ZVswXSkgewogICAgICAgICAgbWF4X3ZhbHVlWzBdID0gc2FtcGxlOwogICAgICAgICAgaWYgKG1heF92YWx1ZVswXSA+IHJhbmdlX21heCkgewogICAgICAgICAgICBtYXhfdmFsdWVbMF0gPSByYW5nZV9tYXg7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGZvciAoY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBvdXRwdXRfY2hhbm5lbHM7ICsrY2hhbm5lbCkgewogICAgICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihyYW5nZV9tYXggKiBjaGFubmVsc1tjaGFubmVsXVtpXSAqIGFtcGxpdHVkZV9zY2FsZSk7CiAgICAgICAgICBpZiAoc2FtcGxlIDwgbWluX3ZhbHVlW2NoYW5uZWxdKSB7CiAgICAgICAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IHNhbXBsZTsKICAgICAgICAgICAgaWYgKG1pbl92YWx1ZVtjaGFubmVsXSA8IHJhbmdlX21pbikgewogICAgICAgICAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IHJhbmdlX21pbjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHNhbXBsZSA+IG1heF92YWx1ZVtjaGFubmVsXSkgewogICAgICAgICAgICBtYXhfdmFsdWVbY2hhbm5lbF0gPSBzYW1wbGU7CiAgICAgICAgICAgIGlmIChtYXhfdmFsdWVbY2hhbm5lbF0gPiByYW5nZV9tYXgpIHsKICAgICAgICAgICAgICBtYXhfdmFsdWVbY2hhbm5lbF0gPSByYW5nZV9tYXg7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKCsrc2NhbGVfY291bnRlciA9PT0gc2NhbGUpIHsKICAgICAgICBmb3IgKGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgb3V0cHV0X2NoYW5uZWxzOyBjaGFubmVsKyspIHsKICAgICAgICAgIGlmIChvcHRpb25zLmJpdHMgPT09IDgpIHsKICAgICAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1pbl92YWx1ZVtjaGFubmVsXSk7CiAgICAgICAgICAgIGRhdGFfdmlldy5zZXRJbnQ4KG9mZnNldCsrLCBtYXhfdmFsdWVbY2hhbm5lbF0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZGF0YV92aWV3LnNldEludDE2KG9mZnNldCwgbWluX3ZhbHVlW2NoYW5uZWxdLCB0cnVlKTsKICAgICAgICAgICAgZGF0YV92aWV3LnNldEludDE2KG9mZnNldCArIDIsIG1heF92YWx1ZVtjaGFubmVsXSwgdHJ1ZSk7CiAgICAgICAgICAgIG9mZnNldCArPSA0OwogICAgICAgICAgfQogICAgICAgICAgbWluX3ZhbHVlW2NoYW5uZWxdID0gSW5maW5pdHk7CiAgICAgICAgICBtYXhfdmFsdWVbY2hhbm5lbF0gPSAtSW5maW5pdHk7CiAgICAgICAgfQogICAgICAgIHNjYWxlX2NvdW50ZXIgPSAwOwogICAgICB9CiAgICB9CiAgICBpZiAoc2NhbGVfY291bnRlciA+IDApIHsKICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgY2hhbm5lbCsrKSB7CiAgICAgICAgaWYgKG9wdGlvbnMuYml0cyA9PT0gOCkgewogICAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1pbl92YWx1ZVtjaGFubmVsXSk7CiAgICAgICAgICBkYXRhX3ZpZXcuc2V0SW50OChvZmZzZXQrKywgbWF4X3ZhbHVlW2NoYW5uZWxdKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGF0YV92aWV3LnNldEludDE2KG9mZnNldCwgbWluX3ZhbHVlW2NoYW5uZWxdLCB0cnVlKTsKICAgICAgICAgIGRhdGFfdmlldy5zZXRJbnQxNihvZmZzZXQgKyAyLCBtYXhfdmFsdWVbY2hhbm5lbF0sIHRydWUpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIGJ1ZmZlcjsKICB9CgogIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIG9ubWVzc2FnZShldnQpIHsKICAgIHZhciBidWZmZXIgPSBnZW5lcmF0ZVdhdmVmb3JtRGF0YShldnQuZGF0YSk7CgogICAgLy8gVHJhbnNmZXIgYnVmZmVyIHRvIHRoZSBjYWxsaW5nIHRocmVhZAogICAgdGhpcy5wb3N0TWVzc2FnZShidWZmZXIsIFtidWZmZXJdKTsKICAgIHRoaXMuY2xvc2UoKTsKICB9OwoKfSkoKTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZWZvcm0tZGF0YS13b3JrZXIuanMubWFwCgo=', null, false);
/* eslint-enable */

/**
 * Provides access to waveform data.
 */

function WaveformData(data) {
  if (isJsonWaveformData(data)) {
    data = convertJsonToBinary(data);
  }
  if (isBinaryWaveformData(data)) {
    this._data = new DataView(data);
    this._offset = this._version() === 2 ? 24 : 20;
    this._channels = [];
    for (var channel = 0; channel < this.channels; channel++) {
      this._channels[channel] = new WaveformDataChannel(this, channel);
    }
  } else {
    throw new TypeError("WaveformData.create(): Unknown data format");
  }
}
var defaultOptions = {
  scale: 512,
  bits: 8,
  amplitude_scale: 1.0,
  split_channels: false,
  disable_worker: false
};
function getOptions(options) {
  var opts = {
    scale: options.scale || defaultOptions.scale,
    bits: options.bits || defaultOptions.bits,
    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,
    split_channels: options.split_channels || defaultOptions.split_channels,
    disable_worker: options.disable_worker || defaultOptions.disable_worker
  };
  return opts;
}
function getChannelData(audio_buffer) {
  var channels = [];
  for (var i = 0; i < audio_buffer.numberOfChannels; ++i) {
    channels.push(audio_buffer.getChannelData(i).buffer);
  }
  return channels;
}
function createFromAudioBuffer(audio_buffer, options, callback) {
  var channels = getChannelData(audio_buffer);
  if (options.disable_worker) {
    var buffer = generateWaveformData({
      scale: options.scale,
      bits: options.bits,
      amplitude_scale: options.amplitude_scale,
      split_channels: options.split_channels,
      length: audio_buffer.length,
      sample_rate: audio_buffer.sampleRate,
      channels: channels
    });
    callback(null, new WaveformData(buffer), audio_buffer);
  } else {
    var worker = new WorkerFactory();
    worker.onmessage = function (evt) {
      callback(null, new WaveformData(evt.data), audio_buffer);
    };
    worker.postMessage({
      scale: options.scale,
      bits: options.bits,
      amplitude_scale: options.amplitude_scale,
      split_channels: options.split_channels,
      length: audio_buffer.length,
      sample_rate: audio_buffer.sampleRate,
      channels: channels
    }, channels);
  }
}
function createFromArrayBuffer(audioContext, audioData, options, callback) {
  // The following function is a workaround for a Webkit bug where decodeAudioData
  // invokes the errorCallback with null instead of a DOMException.
  // See https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata
  // and http://stackoverflow.com/q/10365335/103396

  function errorCallback(error) {
    if (!error) {
      error = new DOMException("EncodingError");
    }
    callback(error);
    // prevent double-calling the callback on errors:
    callback = function callback() {};
  }
  var promise = audioContext.decodeAudioData(audioData, function (audio_buffer) {
    createFromAudioBuffer(audio_buffer, options, callback);
  }, errorCallback);
  if (promise) {
    promise.catch(errorCallback);
  }
}

/**
 * Creates and returns a WaveformData instance from the given waveform data.
 */

WaveformData.create = function create(data) {
  return new WaveformData(data);
};

/**
 * Creates a WaveformData instance from audio.
 */

WaveformData.createFromAudio = function (options, callback) {
  var opts = getOptions(options);
  if (options.audio_context && options.array_buffer) {
    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);
  } else if (options.audio_buffer) {
    return createFromAudioBuffer(options.audio_buffer, opts, callback);
  } else {
    throw new TypeError(
    // eslint-disable-next-line
    "WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object");
  }
};
function WaveformResampler(options) {
  this._inputData = options.waveformData;

  // Scale we want to reach
  this._output_samples_per_pixel = options.scale;
  this._scale = this._inputData.scale; // scale we are coming from

  // The amount of data we want to resample i.e. final zoom want to resample
  // all data but for intermediate zoom we want to resample subset
  this._input_buffer_size = this._inputData.length;
  var input_buffer_length_samples = this._input_buffer_size * this._inputData.scale;
  var output_buffer_length_samples = Math.ceil(input_buffer_length_samples / this._output_samples_per_pixel);
  var output_header_size = 24; // version 2
  var bytes_per_sample = this._inputData.bits === 8 ? 1 : 2;
  var total_size = output_header_size + output_buffer_length_samples * 2 * this._inputData.channels * bytes_per_sample;
  this._output_data = new ArrayBuffer(total_size);
  this.output_dataview = new DataView(this._output_data);
  this.output_dataview.setInt32(0, 2, true); // Version
  this.output_dataview.setUint32(4, this._inputData.bits === 8, true); // Is 8 bit?
  this.output_dataview.setInt32(8, this._inputData.sample_rate, true);
  this.output_dataview.setInt32(12, this._output_samples_per_pixel, true);
  this.output_dataview.setInt32(16, output_buffer_length_samples, true);
  this.output_dataview.setInt32(20, this._inputData.channels, true);
  this._outputWaveformData = new WaveformData(this._output_data);
  this._input_index = 0;
  this._output_index = 0;
  var channels = this._inputData.channels;
  this._min = new Array(channels);
  this._max = new Array(channels);
  var channel;
  for (channel = 0; channel < channels; ++channel) {
    if (this._input_buffer_size > 0) {
      this._min[channel] = this._inputData.channel(channel).min_sample(this._input_index);
      this._max[channel] = this._inputData.channel(channel).max_sample(this._input_index);
    } else {
      this._min[channel] = 0;
      this._max[channel] = 0;
    }
  }
  this._min_value = this._inputData.bits === 8 ? -128 : -32768;
  this._max_value = this._inputData.bits === 8 ? 127 : 32767;
  this._where = 0;
  this._prev_where = 0;
  this._stop = 0;
  this._last_input_index = 0;
}
WaveformResampler.prototype.sample_at_pixel = function (x) {
  return Math.floor(x * this._output_samples_per_pixel);
};
WaveformResampler.prototype.next = function () {
  var count = 0;
  var total = 1000;
  var channels = this._inputData.channels;
  var channel;
  var value;
  var i;
  while (this._input_index < this._input_buffer_size && count < total) {
    while (Math.floor(this.sample_at_pixel(this._output_index) / this._scale) === this._input_index) {
      if (this._output_index > 0) {
        for (i = 0; i < channels; ++i) {
          channel = this._outputWaveformData.channel(i);
          channel.set_min_sample(this._output_index - 1, this._min[i]);
          channel.set_max_sample(this._output_index - 1, this._max[i]);
        }
      }
      this._last_input_index = this._input_index;
      this._output_index++;
      this._where = this.sample_at_pixel(this._output_index);
      this._prev_where = this.sample_at_pixel(this._output_index - 1);
      if (this._where !== this._prev_where) {
        for (i = 0; i < channels; ++i) {
          this._min[i] = this._max_value;
          this._max[i] = this._min_value;
        }
      }
    }
    this._where = this.sample_at_pixel(this._output_index);
    this._stop = Math.floor(this._where / this._scale);
    if (this._stop > this._input_buffer_size) {
      this._stop = this._input_buffer_size;
    }
    while (this._input_index < this._stop) {
      for (i = 0; i < channels; ++i) {
        channel = this._inputData.channel(i);
        value = channel.min_sample(this._input_index);
        if (value < this._min[i]) {
          this._min[i] = value;
        }
        value = channel.max_sample(this._input_index);
        if (value > this._max[i]) {
          this._max[i] = value;
        }
      }
      this._input_index++;
    }
    count++;
  }
  if (this._input_index < this._input_buffer_size) {
    // More to do
    return false;
  } else {
    // Done
    if (this._input_index !== this._last_input_index) {
      for (i = 0; i < channels; ++i) {
        channel = this._outputWaveformData.channel(i);
        channel.set_min_sample(this._output_index - 1, this._min[i]);
        channel.set_max_sample(this._output_index - 1, this._max[i]);
      }
    }
    return true;
  }
};
WaveformResampler.prototype.getOutputData = function () {
  return this._output_data;
};
WaveformData.prototype = {
  _getResampleOptions: function _getResampleOptions(options) {
    var opts = {};
    opts.scale = options.scale;
    opts.width = options.width;
    if (opts.width != null && (typeof opts.width !== "number" || opts.width <= 0)) {
      throw new RangeError("WaveformData.resample(): width should be a positive integer value");
    }
    if (opts.scale != null && (typeof opts.scale !== "number" || opts.scale <= 0)) {
      throw new RangeError("WaveformData.resample(): scale should be a positive integer value");
    }
    if (!opts.scale && !opts.width) {
      throw new Error("WaveformData.resample(): Missing scale or width option");
    }
    if (opts.width) {
      // Calculate the target scale for the resampled waveform
      opts.scale = Math.floor(this.duration * this.sample_rate / opts.width);
    }
    if (opts.scale < this.scale) {
      throw new Error("WaveformData.resample(): Zoom level " + opts.scale + " too low, minimum: " + this.scale);
    }
    opts.abortSignal = options.abortSignal;
    return opts;
  },
  resample: function resample(options) {
    options = this._getResampleOptions(options);
    options.waveformData = this;
    var resampler = new WaveformResampler(options);
    while (!resampler.next()) {
      // nothing
    }
    return new WaveformData(resampler.getOutputData());
  },
  /**
   * Concatenates with one or more other waveforms, returning a new WaveformData object.
   */

  concat: function concat() {
    var self = this;
    var otherWaveforms = Array.prototype.slice.call(arguments);

    // Check that all the supplied waveforms are compatible
    otherWaveforms.forEach(function (otherWaveform) {
      if (self.channels !== otherWaveform.channels || self.sample_rate !== otherWaveform.sample_rate || self.bits !== otherWaveform.bits || self.scale !== otherWaveform.scale) {
        throw new Error("WaveformData.concat(): Waveforms are incompatible");
      }
    });
    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);
    return WaveformData.create(combinedBuffer);
  },
  /**
   * Returns a new ArrayBuffer with the concatenated waveform.
   * All waveforms must have identical metadata (version, channels, etc)
   */

  _concatBuffers: function _concatBuffers() {
    var otherWaveforms = Array.prototype.slice.call(arguments);
    var headerSize = this._offset;
    var totalSize = headerSize;
    var totalDataLength = 0;
    var bufferCollection = [this].concat(otherWaveforms).map(function (w) {
      return w._data.buffer;
    });
    var i, buffer;
    for (i = 0; i < bufferCollection.length; i++) {
      buffer = bufferCollection[i];
      var dataSize = new DataView(buffer).getInt32(16, true);
      totalSize += buffer.byteLength - headerSize;
      totalDataLength += dataSize;
    }
    var totalBuffer = new ArrayBuffer(totalSize);
    var sourceHeader = new DataView(bufferCollection[0]);
    var totalBufferView = new DataView(totalBuffer);

    // Copy the header from the first chunk
    for (i = 0; i < headerSize; i++) {
      totalBufferView.setUint8(i, sourceHeader.getUint8(i));
    }
    // Rewrite the data-length header item to reflect all of the samples concatenated together
    totalBufferView.setInt32(16, totalDataLength, true);
    var offset = 0;
    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);
    for (i = 0; i < bufferCollection.length; i++) {
      buffer = bufferCollection[i];
      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);
      offset += buffer.byteLength - headerSize;
    }
    return totalBuffer;
  },
  slice: function slice(options) {
    var startIndex = 0;
    var endIndex = 0;
    if (options.startIndex != null && options.endIndex != null) {
      startIndex = options.startIndex;
      endIndex = options.endIndex;
    } else if (options.startTime != null && options.endTime != null) {
      startIndex = this.at_time(options.startTime);
      endIndex = this.at_time(options.endTime);
    }
    if (startIndex < 0) {
      throw new RangeError("startIndex or startTime must not be negative");
    }
    if (endIndex < 0) {
      throw new RangeError("endIndex or endTime must not be negative");
    }
    if (startIndex > this.length) {
      startIndex = this.length;
    }
    if (endIndex > this.length) {
      endIndex = this.length;
    }
    if (startIndex > endIndex) {
      startIndex = endIndex;
    }
    var length = endIndex - startIndex;
    var header_size = 24; // Version 2
    var bytes_per_sample = this.bits === 8 ? 1 : 2;
    var total_size = header_size + length * 2 * this.channels * bytes_per_sample;
    var output_data = new ArrayBuffer(total_size);
    var output_dataview = new DataView(output_data);
    output_dataview.setInt32(0, 2, true); // Version
    output_dataview.setUint32(4, this.bits === 8, true); // Is 8 bit?
    output_dataview.setInt32(8, this.sample_rate, true);
    output_dataview.setInt32(12, this.scale, true);
    output_dataview.setInt32(16, length, true);
    output_dataview.setInt32(20, this.channels, true);
    for (var i = 0; i < length * this.channels * 2; i++) {
      var sample = this._at(startIndex * this.channels * 2 + i);
      if (this.bits === 8) {
        output_dataview.setInt8(header_size + i, sample);
      } else {
        output_dataview.setInt16(header_size + i * 2, sample, true);
      }
    }
    return new WaveformData(output_data);
  },
  /**
   * Returns the data format version number.
   */

  _version: function _version() {
    return this._data.getInt32(0, true);
  },
  /**
   * Returns the length of the waveform, in pixels.
   */

  get length() {
    return this._data.getUint32(16, true);
  },
  /**
   * Returns the number of bits per sample, either 8 or 16.
   */

  get bits() {
    var bits = Boolean(this._data.getUint32(4, true));
    return bits ? 8 : 16;
  },
  /**
   * Returns the (approximate) duration of the audio file, in seconds.
   */

  get duration() {
    return this.length * this.scale / this.sample_rate;
  },
  /**
   * Returns the number of pixels per second.
   */

  get pixels_per_second() {
    return this.sample_rate / this.scale;
  },
  /**
   * Returns the amount of time represented by a single pixel, in seconds.
   */

  get seconds_per_pixel() {
    return this.scale / this.sample_rate;
  },
  /**
   * Returns the number of waveform channels.
   */

  get channels() {
    if (this._version() === 2) {
      return this._data.getInt32(20, true);
    } else {
      return 1;
    }
  },
  /**
   * Returns a waveform channel.
   */

  channel: function channel(index) {
    if (index >= 0 && index < this._channels.length) {
      return this._channels[index];
    } else {
      throw new RangeError("Invalid channel: " + index);
    }
  },
  /**
   * Returns the number of audio samples per second.
   */

  get sample_rate() {
    return this._data.getInt32(8, true);
  },
  /**
   * Returns the number of audio samples per pixel.
   */

  get scale() {
    return this._data.getInt32(12, true);
  },
  /**
   * Returns a waveform data value at a specific offset.
   */

  _at: function at_sample(index) {
    if (this.bits === 8) {
      return this._data.getInt8(this._offset + index);
    } else {
      return this._data.getInt16(this._offset + index * 2, true);
    }
  },
  /**
   * Sets a waveform data value at a specific offset.
   */

  _set_at: function set_at(index, sample) {
    if (this.bits === 8) {
      return this._data.setInt8(this._offset + index, sample);
    } else {
      return this._data.setInt16(this._offset + index * 2, sample, true);
    }
  },
  /**
   * Returns the waveform data index position for a given time.
   */

  at_time: function at_time(time) {
    return Math.floor(time * this.sample_rate / this.scale);
  },
  /**
   * Returns the time in seconds for a given index.
   */

  time: function time(index) {
    return index * this.scale / this.sample_rate;
  },
  /**
   * Returns an object containing the waveform data.
   */

  toJSON: function toJSON() {
    var waveform = {
      version: 2,
      channels: this.channels,
      sample_rate: this.sample_rate,
      samples_per_pixel: this.scale,
      bits: this.bits,
      length: this.length,
      data: []
    };
    for (var i = 0; i < this.length; i++) {
      for (var channel = 0; channel < this.channels; channel++) {
        waveform.data.push(this.channel(channel).min_sample(i));
        waveform.data.push(this.channel(channel).max_sample(i));
      }
    }
    return waveform;
  },
  /**
   * Returns the waveform data in binary format as an ArrayBuffer.
   */

  toArrayBuffer: function toArrayBuffer() {
    return this._data.buffer;
  }
};

module.exports = WaveformData;
